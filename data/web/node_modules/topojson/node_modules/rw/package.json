{
  "name": "rw",
  "version": "0.1.4",
  "description": "Wrappers of fs.{read,write}File that work for /dev/std{in,out}.",
  "keywords": [
    "fs",
    "readFile",
    "writeFile",
    "stdin",
    "stdout"
  ],
  "main": "index.js",
  "author": {
    "name": "Mike Bostock",
    "url": "http://bost.ocks.org/mike"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/mbostock/rw.git"
  },
  "readme": "# stdin & stdout, the right way\n\nHow do you read a file from stdin? If you thought,\n\n```js\nvar contents = fs.readFileSync(\"/dev/stdin\", \"utf8\");\n```\n\nyou’d be wrong, because Node only reads up to the size of the file reported by fs.stat rather than reading until it receives an EOF. So, if you redirect a file to your program (`cat file | program`), you’ll only read the first 65,536 bytes of your file. Oops.\n\nWhat about writing a file to stdout? If you thought,\n\n```js\nfs.writeFileSync(\"/dev/stdout\", contents, \"utf8\");\n```\n\nyou’d also be wrong, because this tries to close stdout, so you get this error:\n\n```\nError: UNKNOWN, unknown error\n    at Object.fs.writeSync (fs.js:528:18)\n    at Object.fs.writeFileSync (fs.js:975:21)\n```\n\nShucks. So what should you do?\n\nYou could use a different pattern for reading from stdin:\n\n```js\nvar chunks = [];\n\nprocess.stdin\n    .on(\"data\", function(chunk) { chunks.push(chunk); })\n    .on(\"end\", function() { console.log(chunks.join(\"\").length); })\n    .setEncoding(\"utf8\");\n```\n\nBut that’s a pain, since now your code has two different code paths for reading inputs depending on whether you’re reading a real file or stdin. And the code gets even more complex if you want to [read that file synchronously](https://github.com/mbostock/rw/blob/master/lib/rw/read-file-sync.js).\n\nYou could also try a different pattern for writing to stdout:\n\n```js\nprocess.stdout.write(contents);\n```\n\nOr even:\n\n```js\nconsole.log(contents);\n```\n\nBut if you try to pipe your output to `head`, you’ll get this error:\n\n```\nError: write EPIPE\n    at errnoException (net.js:904:11)\n    at Object.afterWrite (net.js:720:19)\n```\n\nHuh.\n\n## rw\n\nThe **rw** module fixes these problems. It provides an interface just like readFile, readFileSync, writeFile and writeFileSync, but with implementations that work the way you expect on stdin and stdout. If you use these methods on files other than /dev/stdin or /dev/stdout, they simply delegate to the fs methods, so you can trust that they behave identically to the methods you’re used to.\n\nFor example, now you can read stdin synchronously like so:\n\n```js\nvar contents = rw.readFileSync(\"/dev/stdin\", \"utf8\");\n```\n\nOr to write to stdout:\n\n```js\nrw.writeFileSync(\"/dev/stdout\", contents, \"utf8\");\n```\n\nAnd rw automatically squashes EPIPE errors, so you can pipe the output of your program to `head` and you won’t get a spurious stack trace.\n\nTo install, `npm install rw`.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mbostock/rw/issues"
  },
  "homepage": "https://github.com/mbostock/rw",
  "_id": "rw@0.1.4",
  "_from": "rw@0.1"
}
